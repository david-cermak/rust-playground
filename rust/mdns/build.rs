use std::env;
use std::fs;
use std::path::PathBuf;
use serde::Deserialize;

#[derive(Deserialize)]
struct CompileCommand {
    directory: String,
    command: String,
    file: String,
}

fn main() {
    // Path to compile_commands.json generated by CMake
    let compile_commands_path = PathBuf::from("path/to/your/build/dir/compile_commands.json");
    let compile_commands: Vec<CompileCommand> = load_compile_commands(&compile_commands_path);

    // Collect include directories and flags
    let mut include_dirs = Vec::new();
    let mut flags = Vec::new();
    for command in &compile_commands {
        let (command_includes, command_flags) = extract_flags_and_includes(&command.command);
        include_dirs.extend(command_includes);
        flags.extend(command_flags);
    }

    // Remove duplicate includes
    include_dirs.sort();
    include_dirs.dedup();

    // Set up the C build
    let mut build = cc::Build::new();
    build.file("c_src/mdns_networking_socket.c");

    // Add the include directories to the C build
    for include in &include_dirs {
        build.include(include);
    }

    // Compile the C code
    build.compile("mdns_networking");

    // Generate bindings using bindgen
    let mut bindgen_builder = bindgen::Builder::default()
        .header("private_include/mdns_networking.h");

    // Add the same include directories to bindgen
    for include in &include_dirs {
        bindgen_builder = bindgen_builder.clang_arg(format!("-I{}", include));
    }

    // Generate and write bindings
    let bindings = bindgen_builder
        .generate()
        .expect("Unable to generate bindings");

    let out_path = PathBuf::from(env::var("OUT_DIR").unwrap());
    bindings
        .write_to_file(out_path.join("bindings.rs"))
        .expect("Couldn't write bindings!");
}

fn load_compile_commands(path: &PathBuf) -> Vec<CompileCommand> {
    // Read and parse the compile_commands.json file
    let data = fs::read_to_string(path).expect("Failed to read compile_commands.json");
    serde_json::from_str(&data).expect("Failed to parse compile_commands.json")
}

fn extract_flags_and_includes(command: &str) -> (Vec<String>, Vec<String>) {
    let mut flags = Vec::new();
    let mut includes = Vec::new();

    // Split the command into parts
    let parts: Vec<&str> = command.split_whitespace().collect();

    // Parse each part to find flags and include directories
    for part in parts {
        if part.starts_with("-I") {
            // It's an include directory
            includes.push(part[2..].to_string());
        } else if part.starts_with("-D") || part.starts_with("-f") || part.starts_with("-W") {
            // It's a compile flag
            flags.push(part.to_string());
        }
    }

    (includes, flags)
}
